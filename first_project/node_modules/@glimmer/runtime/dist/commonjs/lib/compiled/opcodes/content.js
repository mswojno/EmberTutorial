"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const upsert_1 = require("../../upsert");
const interfaces_1 = require("../../component/interfaces");
const opcodes_1 = require("../../opcodes");
const expressions_1 = require("../expressions");
const update_1 = require("../../vm/update");
const reference_1 = require("@glimmer/reference");
const util_1 = require("@glimmer/util");
const bounds_1 = require("../../bounds");
const builder_1 = require("../../builder");
const builder_2 = require("./builder");
const references_1 = require("../../references");
const builder_3 = require("../../builder");
const opcodes_2 = require("../../opcodes");
opcodes_2.APPEND_OPCODES.add(31 /* DynamicContent */, (vm, { op1: append }) => {
    let opcode = vm.constants.getOther(append);
    opcode.evaluate(vm);
});
function isEmpty(value) {
    return value === null || value === undefined || typeof value['toString'] !== 'function';
}
function normalizeTextValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    return String(value);
}
exports.normalizeTextValue = normalizeTextValue;
function normalizeTrustedValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    if (upsert_1.isString(value)) {
        return value;
    }
    if (upsert_1.isSafeString(value)) {
        return value.toHTML();
    }
    if (upsert_1.isNode(value)) {
        return value;
    }
    return String(value);
}
function normalizeValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    if (upsert_1.isString(value)) {
        return value;
    }
    if (upsert_1.isSafeString(value) || upsert_1.isNode(value)) {
        return value;
    }
    return String(value);
}
class AppendDynamicOpcode {
    evaluate(vm) {
        let reference = vm.frame.getOperand();
        let normalized = this.normalize(reference);
        let value, cache;
        if (reference_1.isConst(reference)) {
            value = normalized.value();
        }
        else {
            cache = new reference_1.ReferenceCache(normalized);
            value = cache.peek();
        }
        let stack = vm.stack();
        let upsert = this.insert(vm.env.getAppendOperations(), stack, value);
        let bounds = new builder_1.Fragment(upsert.bounds);
        stack.newBounds(bounds);
        if (cache /* i.e. !isConst(reference) */) {
            vm.updateWith(this.updateWith(vm, reference, cache, bounds, upsert));
        }
    }
}
exports.AppendDynamicOpcode = AppendDynamicOpcode;
class GuardedAppendOpcode extends AppendDynamicOpcode {
    constructor(expression, symbolTable) {
        super();
        this.expression = expression;
        this.symbolTable = symbolTable;
        this.start = -1;
        this.end = -1;
    }
    evaluate(vm) {
        if (this.start === -1) {
            vm.evaluateOperand(this.expression);
            let value = vm.frame.getOperand().value();
            if (interfaces_1.isComponentDefinition(value)) {
                this.deopt(vm.env);
                vm.pushEvalFrame(this.start, this.end);
            }
            else {
                super.evaluate(vm);
            }
        }
        else {
            vm.pushEvalFrame(this.start, this.end);
        }
    }
    deopt(env) {
        // At compile time, we determined that this append callsite might refer
        // to a local variable/property lookup that resolves to a component
        // definition at runtime.
        //
        // We could have eagerly compiled this callsite into something like this:
        //
        //   {{#if (is-component-definition foo)}}
        //     {{component foo}}
        //   {{else}}
        //     {{foo}}
        //   {{/if}}
        //
        // However, in practice, there might be a large amout of these callsites
        // and most of them would resolve to a simple value lookup. Therefore, we
        // tried to be optimistic and assumed that the callsite will resolve to
        // appending a simple value.
        //
        // However, we have reached here because at runtime, the guard conditional
        // have detected that this callsite is indeed referring to a component
        // definition object. Since this is likely going to be true for other
        // instances of the same callsite, it is now appropiate to deopt into the
        // expanded version that handles both cases. The compilation would look
        // like this:
        //
        //               PutValue(expression)
        //               Test(is-component-definition)
        //               Enter(BEGIN, END)
        //   BEGIN:      Noop
        //               JumpUnless(VALUE)
        //               PutDynamicComponentDefinitionOpcode
        //               OpenComponent
        //               CloseComponent
        //               Jump(END)
        //   VALUE:      Noop
        //               OptimizedAppend
        //   END:        Noop
        //               Exit
        //
        // Keep in mind that even if we *don't* reach here at initial render time,
        // it is still possible (although quite rare) that the simple value we
        // encounter during initial render could later change into a component
        // definition object at update time. That is handled by the "lazy deopt"
        // code on the update side (scroll down for the next big block of comment).
        let dsl = new builder_2.default(this.symbolTable, env);
        dsl.putValue(this.expression);
        dsl.test(IsComponentDefinitionReference.create);
        dsl.labelled(null, (dsl, _BEGIN, END) => {
            dsl.jumpUnless('VALUE');
            dsl.putDynamicComponentDefinition();
            dsl.openComponent(expressions_1.CompiledArgs.empty());
            dsl.closeComponent();
            dsl.jump(END);
            dsl.label('VALUE');
            dsl.dynamicContent(new this.AppendOpcode());
        });
        this.start = dsl.start;
        this.end = dsl.end;
        // From this point on, we have essentially replaced ourselves with a new set
        // of opcodes. Since we will always be executing the new/deopted code, it's
        // a good idea (as a pattern) to null out any unneeded fields here to avoid
        // holding on to unneeded/stale objects:
        // QUESTION: Shouldn't this whole object be GCed? If not, why not?
        this.expression = null;
        return dsl.start;
    }
}
exports.GuardedAppendOpcode = GuardedAppendOpcode;
class IsComponentDefinitionReference extends references_1.ConditionalReference {
    static create(inner) {
        return new IsComponentDefinitionReference(inner);
    }
    toBool(value) {
        return interfaces_1.isComponentDefinition(value);
    }
}
class UpdateOpcode extends opcodes_1.UpdatingOpcode {
    constructor(cache, bounds, upsert) {
        super();
        this.cache = cache;
        this.bounds = bounds;
        this.upsert = upsert;
        this.tag = cache.tag;
    }
    evaluate(vm) {
        let value = this.cache.revalidate();
        if (reference_1.isModified(value)) {
            let { bounds, upsert } = this;
            let { dom } = vm;
            if (!this.upsert.update(dom, value)) {
                let cursor = new bounds_1.Cursor(bounds.parentElement(), bounds_1.clear(bounds));
                upsert = this.upsert = this.insert(vm.env.getAppendOperations(), cursor, value);
            }
            bounds.update(upsert.bounds);
        }
    }
    toJSON() {
        let { _guid: guid, type, cache } = this;
        return {
            guid,
            type,
            details: { lastValue: JSON.stringify(cache.peek()) }
        };
    }
}
class GuardedUpdateOpcode extends UpdateOpcode {
    constructor(reference, cache, bounds, upsert, appendOpcode, state) {
        super(cache, bounds, upsert);
        this.reference = reference;
        this.appendOpcode = appendOpcode;
        this.state = state;
        this.deopted = null;
        this.tag = this._tag = new reference_1.UpdatableTag(this.tag);
    }
    evaluate(vm) {
        if (this.deopted) {
            vm.evaluateOpcode(this.deopted);
        }
        else {
            if (interfaces_1.isComponentDefinition(this.reference.value())) {
                this.lazyDeopt(vm);
            }
            else {
                super.evaluate(vm);
            }
        }
    }
    lazyDeopt(vm) {
        // Durign initial render, we know that the reference does not contain a
        // component definition, so we optimistically assumed that this append
        // is just a normal append. However, at update time, we discovered that
        // the reference has switched into containing a component definition, so
        // we need to do a "lazy deopt", simulating what would have happened if
        // we had decided to perform the deopt in the first place during initial
        // render.
        //
        // More concretely, we would have expanded the curly into a if/else, and
        // based on whether the value is a component definition or not, we would
        // have entered either the dynamic component branch or the simple value
        // branch.
        //
        // Since we rendered a simple value during initial render (and all the
        // updates up until this point), we need to pretend that the result is
        // produced by the "VALUE" branch of the deopted append opcode:
        //
        //   Try(BEGIN, END)
        //     Assert(IsComponentDefinition, expected=false)
        //     OptimizedUpdate
        //
        // In this case, because the reference has switched from being a simple
        // value into a component definition, what would have happened is that
        // the assert would throw, causing the Try opcode to teardown the bounds
        // and rerun the original append opcode.
        //
        // Since the Try opcode would have nuked the updating opcodes anyway, we
        // wouldn't have to worry about simulating those. All we have to do is to
        // execute the Try opcode and immediately throw.
        let { bounds, appendOpcode, state } = this;
        let env = vm.env;
        let deoptStart = appendOpcode.deopt(env);
        let enter = util_1.expect(env.program.opcode(deoptStart + 8), 'hardcoded deopt location');
        let { op1: start, op2: end } = enter;
        let tracker = new builder_3.UpdatableBlockTracker(bounds.parentElement());
        tracker.newBounds(this.bounds);
        let children = new util_1.LinkedList();
        state.frame.condition = IsComponentDefinitionReference.create(util_1.expect(state.frame['operand'], 'operand should be populated'));
        let deopted = this.deopted = new update_1.TryOpcode(start, end, state, tracker, children);
        this._tag.update(deopted.tag);
        vm.evaluateOpcode(deopted);
        vm.throw();
        // From this point on, we have essentially replaced ourselve with a new
        // opcode. Since we will always be executing the new/deopted code, it's a
        // good idea (as a pattern) to null out any unneeded fields here to avoid
        // holding on to unneeded/stale objects:
        // QUESTION: Shouldn't this whole object be GCed? If not, why not?
        this._tag = null;
        this.reference = null;
        this.cache = null;
        this.bounds = null;
        this.upsert = null;
        this.appendOpcode = null;
        this.state = null;
    }
    toJSON() {
        let { _guid: guid, type, deopted } = this;
        if (deopted) {
            return {
                guid,
                type,
                deopted: true,
                children: [deopted.toJSON()]
            };
        }
        else {
            return super.toJSON();
        }
    }
}
class OptimizedCautiousAppendOpcode extends AppendDynamicOpcode {
    constructor() {
        super(...arguments);
        this.type = 'optimized-cautious-append';
    }
    normalize(reference) {
        return reference_1.map(reference, normalizeValue);
    }
    insert(dom, cursor, value) {
        return upsert_1.cautiousInsert(dom, cursor, value);
    }
    updateWith(_vm, _reference, cache, bounds, upsert) {
        return new OptimizedCautiousUpdateOpcode(cache, bounds, upsert);
    }
}
exports.OptimizedCautiousAppendOpcode = OptimizedCautiousAppendOpcode;
class OptimizedCautiousUpdateOpcode extends UpdateOpcode {
    constructor() {
        super(...arguments);
        this.type = 'optimized-cautious-update';
    }
    insert(dom, cursor, value) {
        return upsert_1.cautiousInsert(dom, cursor, value);
    }
}
class GuardedCautiousAppendOpcode extends GuardedAppendOpcode {
    constructor() {
        super(...arguments);
        this.type = 'guarded-cautious-append';
        this.AppendOpcode = OptimizedCautiousAppendOpcode;
    }
    normalize(reference) {
        return reference_1.map(reference, normalizeValue);
    }
    insert(dom, cursor, value) {
        return upsert_1.cautiousInsert(dom, cursor, value);
    }
    updateWith(vm, reference, cache, bounds, upsert) {
        return new GuardedCautiousUpdateOpcode(reference, cache, bounds, upsert, this, vm.capture());
    }
}
exports.GuardedCautiousAppendOpcode = GuardedCautiousAppendOpcode;
class GuardedCautiousUpdateOpcode extends GuardedUpdateOpcode {
    constructor() {
        super(...arguments);
        this.type = 'guarded-cautious-update';
    }
    insert(dom, cursor, value) {
        return upsert_1.cautiousInsert(dom, cursor, value);
    }
}
class OptimizedTrustingAppendOpcode extends AppendDynamicOpcode {
    constructor() {
        super(...arguments);
        this.type = 'optimized-trusting-append';
    }
    normalize(reference) {
        return reference_1.map(reference, normalizeTrustedValue);
    }
    insert(dom, cursor, value) {
        return upsert_1.trustingInsert(dom, cursor, value);
    }
    updateWith(_vm, _reference, cache, bounds, upsert) {
        return new OptimizedTrustingUpdateOpcode(cache, bounds, upsert);
    }
}
exports.OptimizedTrustingAppendOpcode = OptimizedTrustingAppendOpcode;
class OptimizedTrustingUpdateOpcode extends UpdateOpcode {
    constructor() {
        super(...arguments);
        this.type = 'optimized-trusting-update';
    }
    insert(dom, cursor, value) {
        return upsert_1.trustingInsert(dom, cursor, value);
    }
}
class GuardedTrustingAppendOpcode extends GuardedAppendOpcode {
    constructor() {
        super(...arguments);
        this.type = 'guarded-trusting-append';
        this.AppendOpcode = OptimizedTrustingAppendOpcode;
    }
    normalize(reference) {
        return reference_1.map(reference, normalizeTrustedValue);
    }
    insert(dom, cursor, value) {
        return upsert_1.trustingInsert(dom, cursor, value);
    }
    updateWith(vm, reference, cache, bounds, upsert) {
        return new GuardedTrustingUpdateOpcode(reference, cache, bounds, upsert, this, vm.capture());
    }
}
exports.GuardedTrustingAppendOpcode = GuardedTrustingAppendOpcode;
class GuardedTrustingUpdateOpcode extends GuardedUpdateOpcode {
    constructor() {
        super(...arguments);
        this.type = 'trusting-update';
    }
    insert(dom, cursor, value) {
        return upsert_1.trustingInsert(dom, cursor, value);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYi9jb21waWxlZC9vcGNvZGVzL2NvbnRlbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5Q0FXc0I7QUFDdEIsMkRBQW1FO0FBRW5FLDJDQUEyRDtBQUMzRCxnREFBa0U7QUFFbEUsNENBQXFEO0FBQ3JELGtEQUF1RztBQUN2Ryx3Q0FBMEU7QUFDMUUseUNBQTZDO0FBQzdDLDJDQUF5QztBQUN6Qyx1Q0FBeUM7QUFDekMsaURBQXdEO0FBRXhELDJDQUFzRDtBQUV0RCwyQ0FBaUU7QUFFakUsd0JBQWMsQ0FBQyxHQUFHLENBQUMsdUJBQWlCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFO0lBQ3hELElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBbUMsQ0FBQztJQUM3RSxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RCLENBQUMsQ0FBQyxDQUFDO0FBRUgsaUJBQWlCLEtBQWE7SUFDNUIsTUFBTSxDQUFDLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVMsSUFBSSxPQUFPLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxVQUFVLENBQUM7QUFDMUYsQ0FBQztBQUVELDRCQUFtQyxLQUFhO0lBQzlDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkIsTUFBTSxDQUFDLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFDRCxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3ZCLENBQUM7QUFMRCxnREFLQztBQUVELCtCQUErQixLQUFhO0lBQzFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkIsTUFBTSxDQUFDLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFDRCxFQUFFLENBQUMsQ0FBQyxpQkFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwQixNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUNELEVBQUUsQ0FBQyxDQUFDLHFCQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hCLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUNELEVBQUUsQ0FBQyxDQUFDLGVBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEIsTUFBTSxDQUFDLEtBQUssQ0FBQztJQUNmLENBQUM7SUFDRCxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3ZCLENBQUM7QUFFRCx3QkFBd0IsS0FBYTtJQUNuQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25CLE1BQU0sQ0FBQyxFQUFFLENBQUM7SUFDWixDQUFDO0lBQ0QsRUFBRSxDQUFDLENBQUMsaUJBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEIsTUFBTSxDQUFDLEtBQUssQ0FBQztJQUNmLENBQUM7SUFDRCxFQUFFLENBQUMsQ0FBQyxxQkFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLGVBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekMsTUFBTSxDQUFDLEtBQUssQ0FBQztJQUNmLENBQUM7SUFDRCxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3ZCLENBQUM7QUFJRDtJQUtFLFFBQVEsQ0FBQyxFQUFNO1FBQ2IsSUFBSSxTQUFTLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN0QyxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRTNDLElBQUksS0FBSyxFQUFFLEtBQUssQ0FBQztRQUVqQixFQUFFLENBQUMsQ0FBQyxtQkFBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2QixLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQzdCLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLEtBQUssR0FBRyxJQUFJLDBCQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDdkMsS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN2QixDQUFDO1FBRUQsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3ZCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsRUFBRSxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNyRSxJQUFJLE1BQU0sR0FBRyxJQUFJLGtCQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXpDLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFeEIsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUMsQ0FBQztZQUN6QyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDdkUsQ0FBQztJQUNILENBQUM7Q0FDRjtBQTVCRCxrREE0QkM7QUFFRCx5QkFBK0QsU0FBUSxtQkFBc0I7SUFLM0YsWUFBb0IsVUFBbUMsRUFBVSxXQUF3QjtRQUN2RixLQUFLLEVBQUUsQ0FBQztRQURVLGVBQVUsR0FBVixVQUFVLENBQXlCO1FBQVUsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFIakYsVUFBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ1gsUUFBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBSWpCLENBQUM7SUFFRCxRQUFRLENBQUMsRUFBTTtRQUNiLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RCLEVBQUUsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3BDLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDMUMsRUFBRSxDQUFBLENBQUMsa0NBQXFCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNoQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDbkIsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN6QyxDQUFDO1lBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ04sS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNyQixDQUFDO1FBQ0gsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6QyxDQUFDO0lBQ0gsQ0FBQztJQUVNLEtBQUssQ0FBQyxHQUFnQjtRQUMzQix1RUFBdUU7UUFDdkUsbUVBQW1FO1FBQ25FLHlCQUF5QjtRQUN6QixFQUFFO1FBQ0YseUVBQXlFO1FBQ3pFLEVBQUU7UUFDRiwwQ0FBMEM7UUFDMUMsd0JBQXdCO1FBQ3hCLGFBQWE7UUFDYixjQUFjO1FBQ2QsWUFBWTtRQUNaLEVBQUU7UUFDRix3RUFBd0U7UUFDeEUseUVBQXlFO1FBQ3pFLHVFQUF1RTtRQUN2RSw0QkFBNEI7UUFDNUIsRUFBRTtRQUNGLDBFQUEwRTtRQUMxRSxzRUFBc0U7UUFDdEUscUVBQXFFO1FBQ3JFLHlFQUF5RTtRQUN6RSx1RUFBdUU7UUFDdkUsYUFBYTtRQUNiLEVBQUU7UUFDRixxQ0FBcUM7UUFDckMsOENBQThDO1FBQzlDLGtDQUFrQztRQUNsQyxxQkFBcUI7UUFDckIsa0NBQWtDO1FBQ2xDLG9EQUFvRDtRQUNwRCw4QkFBOEI7UUFDOUIsK0JBQStCO1FBQy9CLDBCQUEwQjtRQUMxQixxQkFBcUI7UUFDckIsZ0NBQWdDO1FBQ2hDLHFCQUFxQjtRQUNyQixxQkFBcUI7UUFDckIsRUFBRTtRQUNGLDBFQUEwRTtRQUMxRSxzRUFBc0U7UUFDdEUsc0VBQXNFO1FBQ3RFLHdFQUF3RTtRQUN4RSwyRUFBMkU7UUFFM0UsSUFBSSxHQUFHLEdBQUcsSUFBSSxpQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBRXRELEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzlCLEdBQUcsQ0FBQyxJQUFJLENBQUMsOEJBQThCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFaEQsR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7WUFDbEMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN4QixHQUFHLENBQUMsNkJBQTZCLEVBQUUsQ0FBQztZQUNwQyxHQUFHLENBQUMsYUFBYSxDQUFDLDBCQUFZLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUN4QyxHQUFHLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDckIsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNkLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDbkIsR0FBRyxDQUFDLGNBQWMsQ0FBQyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO1FBQzlDLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQztRQUVuQiw0RUFBNEU7UUFDNUUsMkVBQTJFO1FBQzNFLDJFQUEyRTtRQUMzRSx3Q0FBd0M7UUFFeEMsa0VBQWtFO1FBRWxFLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBOEIsQ0FBQztRQUVqRCxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztJQUNuQixDQUFDO0NBQ0Y7QUFsR0Qsa0RBa0dDO0FBRUQsb0NBQXFDLFNBQVEsaUNBQW9CO0lBQy9ELE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBd0I7UUFDcEMsTUFBTSxDQUFDLElBQUksOEJBQThCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVELE1BQU0sQ0FBQyxLQUFhO1FBQ2xCLE1BQU0sQ0FBQyxrQ0FBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN0QyxDQUFDO0NBQ0Y7QUFFRCxrQkFBaUQsU0FBUSx3QkFBYztJQUNyRSxZQUNZLEtBQXdCLEVBQ3hCLE1BQWdCLEVBQ2hCLE1BQWM7UUFFeEIsS0FBSyxFQUFFLENBQUM7UUFKRSxVQUFLLEdBQUwsS0FBSyxDQUFtQjtRQUN4QixXQUFNLEdBQU4sTUFBTSxDQUFVO1FBQ2hCLFdBQU0sR0FBTixNQUFNLENBQVE7UUFHeEIsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQ3ZCLENBQUM7SUFJRCxRQUFRLENBQUMsRUFBYztRQUNyQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBRXBDLEVBQUUsQ0FBQyxDQUFDLHNCQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RCLElBQUksRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDO1lBQzlCLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7WUFFakIsRUFBRSxDQUFBLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNuQyxJQUFJLE1BQU0sR0FBRyxJQUFJLGVBQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLEVBQUUsY0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0JBQy9ELE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFVLENBQUMsQ0FBQztZQUN2RixDQUFDO1lBRUQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDL0IsQ0FBQztJQUNILENBQUM7SUFFRCxNQUFNO1FBQ0osSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQztRQUV4QyxNQUFNLENBQUM7WUFDTCxJQUFJO1lBQ0osSUFBSTtZQUNKLE9BQU8sRUFBRSxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFO1NBQ3JELENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFFRCx5QkFBd0QsU0FBUSxZQUFlO0lBSTdFLFlBQ1UsU0FBNEIsRUFDcEMsS0FBd0IsRUFDeEIsTUFBZ0IsRUFDaEIsTUFBYyxFQUNOLFlBQW9DLEVBQ3BDLEtBQWM7UUFFdEIsS0FBSyxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFQckIsY0FBUyxHQUFULFNBQVMsQ0FBbUI7UUFJNUIsaUJBQVksR0FBWixZQUFZLENBQXdCO1FBQ3BDLFVBQUssR0FBTCxLQUFLLENBQVM7UUFSaEIsWUFBTyxHQUFzQixJQUFJLENBQUM7UUFXeEMsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksd0JBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVELFFBQVEsQ0FBQyxFQUFjO1FBQ3JCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLEVBQUUsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2xDLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLEVBQUUsQ0FBQyxDQUFDLGtDQUFxQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2xELElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDckIsQ0FBQztZQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNOLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDckIsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO0lBRU8sU0FBUyxDQUFDLEVBQWM7UUFDOUIsdUVBQXVFO1FBQ3ZFLHNFQUFzRTtRQUN0RSx1RUFBdUU7UUFDdkUsd0VBQXdFO1FBQ3hFLHVFQUF1RTtRQUN2RSx3RUFBd0U7UUFDeEUsVUFBVTtRQUNWLEVBQUU7UUFDRix3RUFBd0U7UUFDeEUsd0VBQXdFO1FBQ3hFLHVFQUF1RTtRQUN2RSxVQUFVO1FBQ1YsRUFBRTtRQUNGLHNFQUFzRTtRQUN0RSxzRUFBc0U7UUFDdEUsK0RBQStEO1FBQy9ELEVBQUU7UUFDRixvQkFBb0I7UUFDcEIsb0RBQW9EO1FBQ3BELHNCQUFzQjtRQUN0QixFQUFFO1FBQ0YsdUVBQXVFO1FBQ3ZFLHNFQUFzRTtRQUN0RSx3RUFBd0U7UUFDeEUsd0NBQXdDO1FBQ3hDLEVBQUU7UUFDRix3RUFBd0U7UUFDeEUseUVBQXlFO1FBQ3pFLGdEQUFnRDtRQUVoRCxJQUFJLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFDM0MsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztRQUVqQixJQUFJLFVBQVUsR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXpDLElBQUksS0FBSyxHQUFHLGFBQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLEVBQUUsMEJBQTBCLENBQUMsQ0FBQztRQUNuRixJQUFJLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFDO1FBRXJDLElBQUksT0FBTyxHQUFHLElBQUksK0JBQXFCLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7UUFDaEUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFL0IsSUFBSSxRQUFRLEdBQUcsSUFBSSxpQkFBVSxFQUFrQixDQUFDO1FBRWhELEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLDhCQUE4QixDQUFDLE1BQU0sQ0FBQyxhQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRSw2QkFBNkIsQ0FBQyxDQUFDLENBQUM7UUFFN0gsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGtCQUFTLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRWpGLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUU5QixFQUFFLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzNCLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUVYLHVFQUF1RTtRQUN2RSx5RUFBeUU7UUFDekUseUVBQXlFO1FBQ3pFLHdDQUF3QztRQUV4QyxrRUFBa0U7UUFFbEUsSUFBSSxDQUFDLElBQUksR0FBVyxJQUE4QixDQUFDO1FBQ25ELElBQUksQ0FBQyxTQUFTLEdBQU0sSUFBOEIsQ0FBQztRQUNuRCxJQUFJLENBQUMsS0FBSyxHQUFVLElBQThCLENBQUM7UUFDbkQsSUFBSSxDQUFDLE1BQU0sR0FBUyxJQUE4QixDQUFDO1FBQ25ELElBQUksQ0FBQyxNQUFNLEdBQVMsSUFBOEIsQ0FBQztRQUNuRCxJQUFJLENBQUMsWUFBWSxHQUFHLElBQThCLENBQUM7UUFDbkQsSUFBSSxDQUFDLEtBQUssR0FBVSxJQUE4QixDQUFDO0lBQ3JELENBQUM7SUFFRCxNQUFNO1FBQ0osSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQztRQUUxQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ1osTUFBTSxDQUFDO2dCQUNMLElBQUk7Z0JBQ0osSUFBSTtnQkFDSixPQUFPLEVBQUUsSUFBSTtnQkFDYixRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7YUFDN0IsQ0FBQztRQUNKLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDeEIsQ0FBQztJQUNILENBQUM7Q0FDRjtBQUVELG1DQUEyQyxTQUFRLG1CQUFzQztJQUF6Rjs7UUFDRSxTQUFJLEdBQUcsMkJBQTJCLENBQUM7SUFhckMsQ0FBQztJQVhXLFNBQVMsQ0FBQyxTQUE0QjtRQUM5QyxNQUFNLENBQUMsZUFBRyxDQUFDLFNBQVMsRUFBRSxjQUFjLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRVMsTUFBTSxDQUFDLEdBQXdCLEVBQUUsTUFBYyxFQUFFLEtBQXdCO1FBQ2pGLE1BQU0sQ0FBQyx1QkFBYyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVTLFVBQVUsQ0FBQyxHQUFPLEVBQUUsVUFBNkIsRUFBRSxLQUF3QyxFQUFFLE1BQWdCLEVBQUUsTUFBYztRQUNySSxNQUFNLENBQUMsSUFBSSw2QkFBNkIsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2xFLENBQUM7Q0FDRjtBQWRELHNFQWNDO0FBRUQsbUNBQW9DLFNBQVEsWUFBK0I7SUFBM0U7O1FBQ0UsU0FBSSxHQUFHLDJCQUEyQixDQUFDO0lBS3JDLENBQUM7SUFIVyxNQUFNLENBQUMsR0FBd0IsRUFBRSxNQUFjLEVBQUUsS0FBd0I7UUFDakYsTUFBTSxDQUFDLHVCQUFjLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM1QyxDQUFDO0NBQ0Y7QUFFRCxpQ0FBeUMsU0FBUSxtQkFBc0M7SUFBdkY7O1FBQ0UsU0FBSSxHQUFHLHlCQUF5QixDQUFDO1FBRXZCLGlCQUFZLEdBQUcsNkJBQTZCLENBQUM7SUFhekQsQ0FBQztJQVhXLFNBQVMsQ0FBQyxTQUE0QjtRQUM5QyxNQUFNLENBQUMsZUFBRyxDQUFDLFNBQVMsRUFBRSxjQUFjLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRVMsTUFBTSxDQUFDLEdBQXdCLEVBQUUsTUFBYyxFQUFFLEtBQXdCO1FBQ2pGLE1BQU0sQ0FBQyx1QkFBYyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVTLFVBQVUsQ0FBQyxFQUFNLEVBQUUsU0FBNEIsRUFBRSxLQUF3QyxFQUFFLE1BQWdCLEVBQUUsTUFBYztRQUNuSSxNQUFNLENBQUMsSUFBSSwyQkFBMkIsQ0FBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQy9GLENBQUM7Q0FDRjtBQWhCRCxrRUFnQkM7QUFFRCxpQ0FBa0MsU0FBUSxtQkFBc0M7SUFBaEY7O1FBQ0UsU0FBSSxHQUFHLHlCQUF5QixDQUFDO0lBS25DLENBQUM7SUFIVyxNQUFNLENBQUMsR0FBd0IsRUFBRSxNQUFjLEVBQUUsS0FBd0I7UUFDakYsTUFBTSxDQUFDLHVCQUFjLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM1QyxDQUFDO0NBQ0Y7QUFFRCxtQ0FBMkMsU0FBUSxtQkFBc0M7SUFBekY7O1FBQ0UsU0FBSSxHQUFHLDJCQUEyQixDQUFDO0lBYXJDLENBQUM7SUFYVyxTQUFTLENBQUMsU0FBNEI7UUFDOUMsTUFBTSxDQUFDLGVBQUcsQ0FBQyxTQUFTLEVBQUUscUJBQXFCLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBRVMsTUFBTSxDQUFDLEdBQXdCLEVBQUUsTUFBYyxFQUFFLEtBQXdCO1FBQ2pGLE1BQU0sQ0FBQyx1QkFBYyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVTLFVBQVUsQ0FBQyxHQUFPLEVBQUUsVUFBNkIsRUFBRSxLQUF3QyxFQUFFLE1BQWdCLEVBQUUsTUFBYztRQUNySSxNQUFNLENBQUMsSUFBSSw2QkFBNkIsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2xFLENBQUM7Q0FDRjtBQWRELHNFQWNDO0FBRUQsbUNBQW9DLFNBQVEsWUFBK0I7SUFBM0U7O1FBQ0UsU0FBSSxHQUFHLDJCQUEyQixDQUFDO0lBS3JDLENBQUM7SUFIVyxNQUFNLENBQUMsR0FBd0IsRUFBRSxNQUFjLEVBQUUsS0FBd0I7UUFDakYsTUFBTSxDQUFDLHVCQUFjLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM1QyxDQUFDO0NBQ0Y7QUFFRCxpQ0FBeUMsU0FBUSxtQkFBc0M7SUFBdkY7O1FBQ0UsU0FBSSxHQUFHLHlCQUF5QixDQUFDO1FBRXZCLGlCQUFZLEdBQUcsNkJBQTZCLENBQUM7SUFhekQsQ0FBQztJQVhXLFNBQVMsQ0FBQyxTQUE0QjtRQUM5QyxNQUFNLENBQUMsZUFBRyxDQUFDLFNBQVMsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFUyxNQUFNLENBQUMsR0FBd0IsRUFBRSxNQUFjLEVBQUUsS0FBd0I7UUFDakYsTUFBTSxDQUFDLHVCQUFjLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRVMsVUFBVSxDQUFDLEVBQU0sRUFBRSxTQUE0QixFQUFFLEtBQXdDLEVBQUUsTUFBZ0IsRUFBRSxNQUFjO1FBQ25JLE1BQU0sQ0FBQyxJQUFJLDJCQUEyQixDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDL0YsQ0FBQztDQUNGO0FBaEJELGtFQWdCQztBQUVELGlDQUFrQyxTQUFRLG1CQUFzQztJQUFoRjs7UUFDRSxTQUFJLEdBQUcsaUJBQWlCLENBQUM7SUFLM0IsQ0FBQztJQUhXLE1BQU0sQ0FBQyxHQUF3QixFQUFFLE1BQWMsRUFBRSxLQUF3QjtRQUNqRixNQUFNLENBQUMsdUJBQWMsQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzVDLENBQUM7Q0FDRiJ9